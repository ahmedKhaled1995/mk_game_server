package com.iti.project;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;


public class GameHandler extends Thread{
    private static Logger logger = LoggerFactory.getLogger(GameHandler.class);
    private Socket currentSocket;
    private String userName;
    private DataInputStream dis;
    private PrintStream ps;

    //private static final ArrayList<GameHandler> clientsList = new ArrayList<>(); // I think this can be omitted
    //private static final ArrayList<Game> gameList = new ArrayList<>();
    private static final HashMap<Integer, Game> gameMap = new HashMap<>();
    //private static final ArrayList<String> busyUsers = new ArrayList<>();
    // contains the user and and json object containg the gameId as well as the opponent name
    // Json object has two keys 'gameId' and 'opponentName'
    private static final HashMap<String, JSONObject> usersIngame = new HashMap<>();
    private static final HashMap<String, GameHandler> nameSocketMap = new HashMap<>();
    private volatile boolean isInterrupted = false;
    public GameHandler(Socket cs)  {
        try {
            this.currentSocket = cs;
            this.dis = new DataInputStream(cs.getInputStream());
            this.ps= new PrintStream(cs.getOutputStream());
            //clientsList.add(this);
            this.start(); // To start the thread execution, by calling the run() method (defined below)
        } catch (IOException e) {
            e.printStackTrace();
            //closeConnection();
        }
    }

    public boolean equals(GameHandler other){
        return this.currentSocket.equals(other.currentSocket);
    }

    private void closeConnection(){
        try {
            this.currentSocket.close();
            this.dis.close();
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
        this.ps.close();
        //System.out.println("Closed Connection user name: " + this.userName);
        //System.out.println("Connection count before closeing coonection: " + nameSocketMap.size());
        //clientsList.remove(this);
        //GameHandler removedClient = null;
        if(this.userName != null){
            //removedClient = nameSocketMap.remove(this.userName);
            nameSocketMap.remove(this.userName);
        }
        //System.out.println("Connection count after closeing conection: " + nameSocketMap.size());
        handleClientLeaving();
        System.out.println("Closing socket");
    }

    /*private String getKey(GameHandler value){
        String key = null;
        for (Map.Entry<String,GameHandler> entry : nameSocketMap.entrySet()){
            if(entry.getValue().equals(value)){
                key = entry.getKey();
                break;
            }
        }
        return key;
    }*/

    @Override
    public void run(){
        while(!isInterrupted) {
            String str= null;
            try {
                str = dis.readLine();
                handleClientReply(str);
            } catch (IOException e) {
                // Handle exception here if a client exits (generated by str = dis.readLine())
                //e.printStackTrace();
                closeConnection();
                break;
            }
            finally {
                logger.info("Game Handler thread {} is shutting down",this.getId());
            }
        }
    }
    // note that we are not calling this method interrupt since this class is implements Thread which has its own interrupt method
    // That is why I recommend against extending Thread classes or any other classes in general unless you absolutely must
    public void interruptCustom()
    {
        logger.info("Game Handler thread {} received the interrupt command",this.getId());
        this.isInterrupted=true;
    }
    private void broadCast(String msg) {
        /*for (GameHandler gameHandler : clientsList) {
            gameHandler.ps.println(msg);
        }*/
        for (Map.Entry<String,GameHandler> entry : nameSocketMap.entrySet()){
            entry.getValue().ps.println(msg);
        }
    }

    private void handleClientReply(String reply){
        JSONObject replyJson = parseStringToJsonObject(reply);
        String type = replyJson.get("type").toString();
        if(type.equals("gameTurn")){
            int gameId = Integer.parseInt(replyJson.get("gameId").toString());
            String position = replyJson.get("position").toString();
            gameMap.get(gameId).nextTurn(position);
            handleNextTurn(gameId);
        }else if(type.equals("login")){
            String name = replyJson.get("userName").toString();
            boolean success = false;
            // Checking if the name exists in the database and the user is not already logged in
            if(GameServer.getUsers().contains(name) && nameSocketMap.get(name) == null){
                nameSocketMap.put(name, this);
                success = true;
            }
            handleLogin(success, name);
        }else if(type.equals("getUsers")){
            handleSendAllUsers();
        }else if(type.equals("tryGameWithOpponent")){
            String possibleOpponentName = replyJson.get("opponent").toString();
            if(nameSocketMap.get(possibleOpponentName) == null){  // opponent is not online
                handleGameRejection(possibleOpponentName + " is currently not online!", null);
            }else if(usersIngame.get(possibleOpponentName) == null){  // opponent is free to play
                //handleGameStart(possibleOpponentName);
                askOpponentForGame(possibleOpponentName);
            }else{    // opponent is busy (in other game)
                handleGameRejection("Opponents is in another game!", null);
            }
        }else if(type.equals("startGameResponse")){
            String gameAccepted = replyJson.get("result").toString();
            String opponentName = replyJson.get("opponent").toString();
            if(gameAccepted.equals("true")){
                System.out.println("Game accepted");
                handleGameStart(opponentName);
            }else{
                System.out.println("Game rejected");
                handleGameRejection(this.userName + " declined the game!", opponentName);
            }
        }
    }

    private void handleNextTurn(int gameId){
        Game game = gameMap.get(gameId);
        JSONObject sendToClient = this.createJsonObject();
        JSONArray array = new JSONArray();
        for(int i : game.getButtons()){
            array.add(i);
        }
        sendToClient.put("type", "gameTurnResult");
        sendToClient.put("newValues", array);
        game.getPlayerOne().ps.println(sendToClient.toJSONString());
        game.getPlayerTwo().ps.println(sendToClient.toJSONString());
    }

    private void handleSendAllUsers(){
        JSONObject sendToClient = this.createJsonObject();
        JSONArray allUsers = new JSONArray();
        JSONArray availableUsers = new JSONArray();
        for(String user : GameServer.getUsers()){
            allUsers.add(user);
        }
        for (Map.Entry<String,GameHandler> entry : nameSocketMap.entrySet()){
            availableUsers.add(entry.getKey());
        }
        sendToClient.put("type", "usersList");
        sendToClient.put("users", allUsers);
        sendToClient.put("availableUsers", availableUsers);
        this.ps.println(sendToClient.toJSONString());
    }

    // Used to notify other clients when a new client connects
    private void signalOnlineUser(String loggedInUser){
        JSONObject sendToClient = this.createJsonObject();
        sendToClient.put("type", "newLoggedInUser");
        sendToClient.put("loggedInUser", loggedInUser);
        broadCast(sendToClient.toJSONString());
    }

    // Used to notify other clients when a client leaves
    private void signalUserLogout(String loggedOutUser){
        JSONObject sendToClient = this.createJsonObject();
        sendToClient.put("type", "loggedOutUser");
        sendToClient.put("loggedOutUser", loggedOutUser);
        broadCast(sendToClient.toJSONString());
    }

    private void handleGameStart(String opponent){
        // Creating game info
        int gameId = gameMap.size();  // gameId starts at zero
        GameHandler playerOne = this;  // the user who was asked to start a game
        GameHandler playerTwo = nameSocketMap.get(opponent);   // the user who requested the game
        // Storing game info
        JSONObject playerOneGameInfo = createJsonObject();
        playerOneGameInfo.put("gameId", gameId);
        playerOneGameInfo.put("opponentName", opponent);
        JSONObject playerTwoGameInfo = createJsonObject();
        playerTwoGameInfo.put("gameId", gameId);
        playerTwoGameInfo.put("opponentName", this.userName);
        usersIngame.put(this.userName, playerOneGameInfo);
        usersIngame.put(opponent, playerTwoGameInfo);
        // Stariting game and adding it to games list
        Game newGame = new Game(gameId, playerOne, playerTwo);
        gameMap.put(gameId ,newGame);
        // Sending to both players game start info
        JSONObject sendToClient = this.createJsonObject();
        sendToClient.put("type", "startGame");
        sendToClient.put("gameId", gameId);
        sendToClient.put("opponent", opponent);
        newGame.getPlayerOne().ps.println(sendToClient.toJSONString());
        newGame.getPlayerTwo().ps.println(sendToClient.toJSONString());
    }

    private void handleLogin(boolean success, String userName){
        JSONObject object = createJsonObject();
        object.put("type", "loginResult");
        object.put("success", success);
        if(success){
            object.put("userName", userName);
            this.userName = userName;
        }
        this.ps.println(object.toJSONString());
        // Notifying other clients a new player has joined
        if(success){
            signalOnlineUser(userName);
        }
    }

    // Connecetions are already closed and user is removed from both
    // clientList, nameSocketMap when this methods is called,
    // All we handle is check if the client that left is in game or not
    // and if he is in game, we terminate the game
    // and the remove the game from gamesList and remove the client from usersIngame map
    private void handleClientLeaving(){
        JSONObject gameInfo = usersIngame.get(this.userName);
        if(gameInfo != null){  // That means that the client left was in a game
            int gameId = Integer.parseInt(gameInfo.get("gameId").toString());
            String opponentName = gameInfo.get("opponentName").toString();
            // Now we remove the two users from the map, and we notify the other client
            // that the game has been terminated
            JSONObject sendToOtherClient = createJsonObject();
            sendToOtherClient.put("type", "gameTerminated");
            nameSocketMap.get(opponentName).ps.println(sendToOtherClient.toJSONString());
            usersIngame.remove(this.userName);
            usersIngame.remove(opponentName);
            gameMap.remove(gameId);
            // Here, I am notifying other clients that client has left (to update the listview in the frontend)
        }
        signalUserLogout(this.userName);
    }

    private void handleGameRejection(String error, String opponent){
        if(opponent != null){ // Means game was rejected because user declined
            // Note that the opponent String in the method argument is the player who requested the game
            GameHandler userWhoRequestedGame = nameSocketMap.get(opponent);
            JSONObject sendToClient = createJsonObject();
            sendToClient.put("type", "gameRejected");
            sendToClient.put("error", error);
            userWhoRequestedGame.ps.println(sendToClient.toJSONString());
        }else{   // Means user was rejected because opponent is busy (in another game) or offline
            JSONObject sendToClient = createJsonObject();
            sendToClient.put("type", "gameRejected");
            sendToClient.put("error", error);
            this.ps.println(sendToClient.toJSONString());
        }

    }

    private void askOpponentForGame(String opponentName) {
        GameHandler opponentClient = nameSocketMap.get(opponentName);
        JSONObject sendToOpponent = createJsonObject();
        sendToOpponent.put("type", "startGameRequest");
        sendToOpponent.put("opponentName", this.userName);
        opponentClient.ps.println(sendToOpponent.toJSONString());
    }

    private JSONObject createJsonObject(){
        return new JSONObject();
    }

    private JSONObject parseStringToJsonObject(String jsonString){
        JSONParser parser = new JSONParser();
        try {
            return (JSONObject) parser.parse(jsonString);
        } catch (ParseException e) {
            e.printStackTrace();
            return null;
        }
    }
}